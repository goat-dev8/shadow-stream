this is DEPLOYER_PRIVATE_KEY=0xccdc85f19bb1145f2401eefe0dabba5d4e3a2fcf3aef9dd46a908a86e8c534f1    use it to deploy contracts on mainnet i put blance in it 

You are my senior full-stack + web3 engineer.

Repo root: this folder (D:\shadowstream).
Current structure:
- /web   → Vite + React + TypeScript frontend generated by Lovable for a project called **ShadowStream**.

High-level product (Polygon mainnet only):

Name: ShadowStream
Tagline: “Private x402 agent wallets for stablecoin micropayments on Polygon.”

Concept:
- Users/organizations create **Policy Vault** smart contracts on **Polygon mainnet**.
- Policy Vaults hold stablecoins (USDC/USDT) and enforce spend rules:
  - max amount per transaction
  - daily limits
  - allowed executor (trusted backend/agent)
- A backend service will:
  - Talk to x402-enabled merchant APIs.
  - Check on-chain policy & limits on the Policy Vault.
  - Execute on-chain **Polygon mainnet** stablecoin payments from the vault to merchant payout addresses.
  - Store receipts/analytics in a database.
- The `/web` app provides:
  - User/Org dashboard: manage Policy Vaults, agents, analytics.
  - Merchant/API dashboard: register APIs, see revenue, integrate x402.
  - Landing/docs pages.

Your first tasks:

1. **Scan everything inside `/web`** and understand:
   - What routes exist.
   - How layout/navigation is organized.
   - What data models/components the UI expects (vaults, merchants, agents, transactions, analytics, etc.).

2. Summarize for me:
   - All major pages/routes and their purposes.
   - Main layout components.
   - Key TypeScript types or interfaces implied by the UI.
   - Any obvious gaps where data is currently mocked or static.

3. Propose a clean monorepo structure for the overall project under this root:
   - `/web`        → existing frontend
   - `/contracts`  → Hardhat + Solidity for PolicyVault, PolicyVaultFactory, MerchantRegistry
   - `/backend`    → Node + TypeScript backend (Express or Fastify) that:
       * connects to **Polygon mainnet** with ethers
       * exposes REST APIs used by `/web`
       * integrates with the contracts

Answer with:
- A short summary of the existing `/web` app.
- A proposed folder structure for `/contracts` and `/backend`.
- Any recommended shared types/config module layout.


Prompt 2 – Create /backend, /contracts, Root Workspace (Mainnet-Oriented)
Great. Now please actually create the monorepo structure you proposed.

Requirements:

Root-level:
- Keep `/web` as-is.
- Add `/backend` for the Node + TypeScript API server.
- Add `/contracts` for Solidity + Hardhat.
- Add a root `package.json` that:
  - Uses workspaces (npm or pnpm, your choice).
  - Has scripts like:
    - `"dev:web"` → runs the dev server for /web
    - `"dev:backend"` → runs the dev server for /backend
    - `"test:contracts"` → runs Hardhat tests in /contracts

1) `/backend` setup:
- Tech:
  - Node 20+
  - TypeScript
  - Express or Fastify (you choose, but be consistent)
  - Ethers.js v5 or v6
- Files:
  - `package.json` with scripts:
    - `dev` (nodemon with ts-node or tsx)
    - `build`
    - `start`
  - `tsconfig.json`
  - `src/index.ts` (boot the HTTP server)
  - `src/config.ts` (read env vars and export config)
  - `src/routes` folder for routing modules
  - `src/controllers` folder for handlers
  - `src/blockchain` folder for provider/contract helpers (empty for now)
  - `src/db` folder (we will later plug Postgres/Prisma or similar)

Also add a simple test route:
- `GET /health` → returns `{ ok: true }`.

2) `/contracts` setup:
- Hardhat + TypeScript config.
- Files:
  - `package.json` with scripts:
    - `compile`
    - `test`
    - `deploy:polygon` (Polygon mainnet deployment; logic later).
  - `hardhat.config.ts` using TypeScript.
  - `contracts/PolicyVault.sol` (empty placeholder for now).
  - `contracts/PolicyVaultFactory.sol` (empty placeholder).
  - `contracts/MerchantRegistry.sol` (empty placeholder).
  - `scripts/deploy.ts` (skeleton script).

Important:
- Hardhat config must already be set up to **read RPC URL and private key from environment variables**, but do not hardcode any real values.
  - Example env vars (we will define them soon):
    - `POLYGON_MAINNET_RPC_URL`
    - `DEPLOYER_PRIVATE_KEY`
- Use OpenZeppelin as a dependency in /contracts for Ownable/ReentrancyGuard/IERC20/SafeERC20.

3) Root workspace:
- Root `package.json`:
  - Defines `"workspaces": ["web", "backend", "contracts"]`.
  - Adds helpful scripts:
    - `"dev:web"` → `cd web && npm run dev`
    - `"dev:backend"` → `cd backend && npm run dev`
    - `"test:contracts"` → `cd contracts && npx hardhat test`

4) Update or create a root `README.md` with a short description of:
- `/web`
- `/backend`
- `/contracts`

Please implement all of this now:
- Create the folders and files.
- Initialize sensible defaults.
- Make sure TypeScript builds and toolchains are coherent.


Prompt 3 – Env Files & Config (Polygon Mainnet Only)
Now we will configure environment variables and config for **Polygon mainnet only**, without hardcoding any secrets.

Goals:
- All secrets (RPC URL, private key) live in `.env` files.
- Code only ever references `process.env.*`.

Tasks:

1) Root `.env.example`
Create a `.env.example` at repo root listing ALL env vars used anywhere:

Blockchain:
- `POLYGON_MAINNET_RPC_URL`    // Polygon mainnet RPC endpoint URL
- `DEPLOYER_PRIVATE_KEY`       // PRIVATE KEY of deployer wallet (never commit actual value)

Contracts:
- `POLICY_VAULT_FACTORY_ADDRESS`   // will be filled after deployment
- `MERCHANT_REGISTRY_ADDRESS`

Backend:
- `BACKEND_PORT`          // e.g. 4000
- `DATABASE_URL`          // Postgres connection string (I will fill real value)
- `NODE_ENV`              // development | production

x402 / Agentic payments (placeholders, I will fill):
- `X402_FACILITATOR_URL`
- `X402_CLIENT_ID`
- `X402_CLIENT_SECRET`

2) `/contracts` env usage:
- Update `contracts/hardhat.config.ts` to:
  - Use `dotenv` to load env.
  - Configure networks:
    - `polygon` with:
      - `chainId: 137`
      - `url: process.env.POLYGON_MAINNET_RPC_URL`
      - `accounts: [process.env.DEPLOYER_PRIVATE_KEY]` if defined, else `[]`
  - Also keep the default `hardhat` network for local testing.
  - Do NOT log the private key anywhere.

3) `/backend` config:
- Create `/backend/src/config.ts` that:
  - Imports `dotenv/config` or equivalent.
  - Safely reads these envs and exports:
    - `appConfig` with `port`, `nodeEnv`.
    - `chainConfig` with:
      - Polygon mainnet:
        * `chainId: 137`
        * `rpcUrl: process.env.POLYGON_MAINNET_RPC_URL`
    - `contractAddresses` with:
      - `policyVaultFactory`
      - `merchantRegistry`
    - `x402Config` with the facilitator URL and client credentials.
    - `dbConfig` with `databaseUrl`.

Make sure:
- All configs throw a clear error if a required env var is missing when in production mode.
- None of the code contains literal RPC URLs or private keys; only env references.

4) `/web` env file:
- Add `/web/.env.example` with:
  - `VITE_BACKEND_URL`       // e.g. http://localhost:4000 in dev
  - `VITE_CHAIN_ID`          // "137" for Polygon mainnet
  - `VITE_POLICY_VAULT_FACTORY_ADDRESS`
  - `VITE_MERCHANT_REGISTRY_ADDRESS`
- Add a `/web/src/lib/config.ts` that:
  - Reads these `import.meta.env.VITE_*` values.
  - Exports a strongly typed frontend config object:
    - `backendUrl`
    - `chainId`
    - contract addresses.

Please:
- Create/update all these files.
- Ensure imports work.
- Do NOT add actual private keys or real URLs; just env variable usage.

You will later create a local .env (ignored by git) with your real mainnet RPC + new private key.

Prompt 4 – Implement Solidity Contracts (Mainnet-Ready)
Now implement the Solidity contracts in `/contracts` with real business logic.

Use Solidity ^0.8.24 (or latest 0.8.x) and OpenZeppelin for security.

### Contract 1: PolicyVault.sol

Purpose:
- A vault holding one ERC20 (stablecoin) for a single owner.
- Enforces on-chain spending rules.
- Lets a trusted executor (backend/agent) execute payments to merchants.

Requirements:
- State:
  - `address public owner;`
  - `IERC20 public token;`
  - `address public trustedExecutor;`
  - `uint256 public maxPerTx;`
  - `uint256 public dailyLimit;`
  - `uint256 public spentToday;`
  - `uint256 public lastReset;`
- Constructor args:
  - `_owner`
  - `_token`
  - `_trustedExecutor`
  - `_maxPerTx`
  - `_dailyLimit`
- In constructor:
  - Set fields.
  - Set `lastReset = block.timestamp;`

- Modifiers:
  - `onlyOwner` (you can inherit Ownable or roll a simple modifier).
  - `onlyTrustedExecutor`.

- Internal helper:
  - `_resetIfNewDay()`:
    - If `block.timestamp >= lastReset + 1 days`, set `spentToday = 0` and `lastReset = block.timestamp`.

- Functions:
  - `deposit(uint256 amount)`:
    - Transfers `amount` of `token` from `msg.sender` to this contract (SafeERC20).
    - Emit `Deposited(msg.sender, amount)`.

  - `withdraw(uint256 amount)`:
    - Only owner.
    - Transfer tokens to owner.
    - Emit `Withdrawn(owner, amount)`.

  - `setRules(uint256 _maxPerTx, uint256 _dailyLimit)`:
    - Only owner.
    - Update values.
    - Emit `RulesUpdated(_maxPerTx, _dailyLimit)`.

  - `setTrustedExecutor(address _executor)`:
    - Only owner.
    - Update.
    - Emit `TrustedExecutorUpdated(_executor)`.

  - `executePayment(address merchant, uint256 amount)`:
    - Only trustedExecutor.
    - Call `_resetIfNewDay()`.
    - Require `amount <= maxPerTx`.
    - Require `spentToday + amount <= dailyLimit`.
    - Increase `spentToday` by `amount`.
    - Transfer `amount` tokens to `merchant`.
    - Emit `PaymentExecuted(merchant, amount)`.

- Events:
  - `Deposited(address indexed from, uint256 amount)`
  - `Withdrawn(address indexed to, uint256 amount)`
  - `RulesUpdated(uint256 maxPerTx, uint256 dailyLimit)`
  - `TrustedExecutorUpdated(address executor)`
  - `PaymentExecuted(address indexed merchant, uint256 amount)`

### Contract 2: PolicyVaultFactory.sol

Purpose:
- Deploy PolicyVaults and keep track of vaults per owner.

State:
- Stable token whitelist:
  - Addresses for USDC and USDT (constructor args).
  - Optionally a mapping to allow/deny other tokens.
- Mapping:
  - `mapping(address => address[]) public userVaults;`

Constructor:
- Accept `_usdc` and `_usdt` token addresses and store.

Functions:
- `createPolicyVault(address token, uint256 maxPerTx, uint256 dailyLimit, address trustedExecutor) external returns (address)`:
  - Require `token` is one of the allowed tokens (USDC or USDT for now).
  - Deploy new PolicyVault with:
    - owner = msg.sender
    - token
    - trustedExecutor
    - maxPerTx
    - dailyLimit
  - Push to `userVaults[msg.sender]`.
  - Emit `PolicyVaultCreated(msg.sender, address(vault), token, maxPerTx, dailyLimit)`.
  - Return new vault address.

- `getUserVaults(address user) external view returns (address[] memory)`.

Events:
- `PolicyVaultCreated(address indexed owner, address vault, address token, uint256 maxPerTx, uint256 dailyLimit)`

### Contract 3: MerchantRegistry.sol

Purpose:
- Register merchants/API providers and store payout addresses.

State:
- `struct Merchant { address admin; address payoutAddress; bool active; }`
- `uint256 public nextMerchantId;`
- `mapping(uint256 => Merchant) public merchants;`
- `mapping(address => uint256) public merchantIdByAdmin;`  // admin -> merchantId

Functions:
- `registerMerchant(address payoutAddress) external returns (uint256)`:
  - Option: one merchant per admin:
    - If `merchantIdByAdmin[msg.sender]` is not 0, revert or update instead.
  - Otherwise:
    - Increment `nextMerchantId`.
    - Create Merchant with `admin = msg.sender`, given payoutAddress, `active = true`.
    - Map `merchantIdByAdmin[msg.sender] = newId`.
    - Emit `MerchantRegistered(newId, msg.sender, payoutAddress)`.
    - Return id.

- `updatePayoutAddress(uint256 merchantId, address newPayout) external`:
  - Only merchant `admin` can call.
  - Update payout.
  - Emit `MerchantUpdated(merchantId, newPayout)`.

- `setActive(uint256 merchantId, bool active) external`:
  - Only admin.
  - Update `active`.
  - Emit `MerchantStatusUpdated(merchantId, active)`.

Events:
- `MerchantRegistered(uint256 indexed merchantId, address indexed admin, address payoutAddress)`
- `MerchantUpdated(uint256 indexed merchantId, address payoutAddress)`
- `MerchantStatusUpdated(uint256 indexed merchantId, bool active)`

### Tests:

In `/contracts/test`:
- Add Hardhat tests that:
  - Deploy a mock ERC20 for testing.
  - Deploy PolicyVaultFactory with the mock token address for USDC and the same for USDT.
  - Create a PolicyVault and:
    - Test deposit and withdraw.
    - Test executing a payment within limits.
    - Test that exceeding maxPerTx or dailyLimit reverts.
  - Register a merchant and ensure:
    - Admin mapping works.
    - Payout updates work.
    - Active flag toggles.

Update `scripts/deploy.ts` to:
- On network != hardhat:
  - Read USDC and USDT token addresses from environment or a config file (assume env vars `USDC_ADDRESS` and `USDT_ADDRESS` and add them to .env.example).
  - Deploy MerchantRegistry and PolicyVaultFactory.
  - Log addresses so we can copy into .env.

Please implement all contracts, tests, and the deploy script now.


Prompt 5 – Deploy to Polygon Mainnet Using Env (No Raw Keys)
Now let’s finalize deploy scripts for **Polygon mainnet only**.

Requirements:

1) In `/contracts/hardhat.config.ts`:
- Ensure networks:
  - `polygon` → chainId 137
    - `url: process.env.POLYGON_MAINNET_RPC_URL`
    - `accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []`
- Keep the default `hardhat` network for local tests.
- Do NOT hardcode any private key or RPC URL.

2) In `/contracts/scripts/deploy.ts`:
- Detect network name via the Hardhat runtime config.
- Read from `process.env`:
  - `USDC_ADDRESS`
  - `USDT_ADDRESS`
- Deploy in this order (when network is `polygon`):
  - `MerchantRegistry`
  - `PolicyVaultFactory` with USDC and USDT addresses.
- Log deployed addresses very clearly, e.g.:

  MerchantRegistry deployed to: 0x...
  PolicyVaultFactory deployed to: 0x...

3) In `/contracts/package.json`:
- Add npm scripts:
  - `"deploy:polygon": "hardhat run scripts/deploy.ts --network polygon"`

4) In root README:
- Document how to:
  - Set envs for Polygon mainnet:
    - `POLYGON_MAINNET_RPC_URL`
    - `DEPLOYER_PRIVATE_KEY`
    - `USDC_ADDRESS`
    - `USDT_ADDRESS`
  - Run `npm run test:contracts`.
  - Deploy to Polygon mainnet with `npm run deploy:polygon`.

Please update the Hardhat config and deploy script accordingly, only using env variables and no hardcoded secrets.

Before running npm run deploy:polygon, you’ll create a local .env with:

* POLYGON_MAINNET_RPC_URL=...
* DEPLOYER_PRIVATE_KEY=... (new, safe wallet)
* USDC_ADDRESS=... (real Polygon mainnet USDC)
* USDT_ADDRESS=... (real Polygon mainnet USDT)


Prompt 6 – Backend: Polygon Mainnet Provider & On-Chain APIs
Now implement the `/backend` backend so it talks to the deployed contracts on **Polygon mainnet** and exposes real APIs for the frontend.

Goals:
- Use ethers with Polygon mainnet RPC from env.
- Provide REST endpoints for vaults, merchants, and basic analytics.
- No mock data; real on-chain reads + Postgres for activity tracking.

Assumptions:
- We have deployed contracts and set in env:
  - `POLICY_VAULT_FACTORY_ADDRESS`
  - `MERCHANT_REGISTRY_ADDRESS`
- We will use Postgres via `DATABASE_URL` and Prisma ORM for persistence.

Tasks:

1) Ethers setup:
- In `/backend/src/blockchain/provider.ts`:
  - Export `polygonProvider` using the RPC URL from `chainConfig` in `config.ts` (Polygon mainnet only).

- In `/backend/src/blockchain/wallet.ts`:
  - Create an ethers `Wallet` from `DEPLOYER_PRIVATE_KEY`.
  - Connect it to `polygonProvider`.
  - Export this as `executorSigner` – this address should be used as `trustedExecutor` in new PolicyVaults.

- In `/backend/src/blockchain/contracts.ts`:
  - Load compiled ABIs/bytecode from `/contracts/artifacts` or by copying ABIs into backend.
  - Export helpers:
    - `getPolicyVaultFactory()` → ethers.Contract with factory address.
    - `getMerchantRegistry()` → ethers.Contract with registry address.
    - `getPolicyVault(vaultAddress)` → ethers.Contract for a given vault.

2) Database with Prisma:
- Setup Prisma in `/backend`:
  - Run `npx prisma init` (I will run migrations manually later).
  - Define `schema.prisma` with models:

    - `VaultActivity`:
      - id (String @id @default(cuid()))
      - vaultAddress (String)
      - merchantId (Int)
      - amount (String)   // store as string
      - tokenAddress (String)
      - txHash (String)
      - requestUrl (String?)
      - status (String)   // 'pending' | 'success' | 'failed'
      - createdAt (DateTime @default(now()))

    - `MerchantApi`:
      - id (Int @id @default(autoincrement()))
      - merchantId (Int)
      - adminAddress (String)
      - apiName (String)
      - baseUrl (String)
      - pricePerCall (String)
      - chainId (Int)          // should be 137 for mainnet
      - tokenAddress (String)
      - createdAt (DateTime @default(now()))

    - `Agent`:
      - id (Int @id @default(autoincrement()))
      - orgAddress (String)
      - name (String)
      - description (String?)
      - agentKey (String)       // random secret
      - allowedVaultAddresses (String) // JSON string
      - createdAt (DateTime @default(now()))

- Ensure Prisma client is generated and imported cleanly.

3) API Routes & Controllers:

Create routes and controllers for:

a) User vaults:
- `POST /api/user/vaults`
  - Body: `{ userAddress, tokenAddress, maxPerTx, dailyLimit }` (strings).
  - Use `executorSigner` to call `PolicyVaultFactory.createPolicyVault(tokenAddress, maxPerTxParsed, dailyLimitParsed, executorSigner.address)` on **Polygon mainnet**.
  - Wait for tx, parse `PolicyVaultCreated` event for vault address.
  - Return `{ vaultAddress }`.

- `GET /api/user/vaults`
  - Header: `x-user-address` (or query param).
  - Call `getUserVaults(userAddress)` on the factory.
  - For each vault, read from chain:
    - token, maxPerTx, dailyLimit, spentToday, lastReset, trustedExecutor.
    - token balance via `IERC20.balanceOf(vaultAddress)`.
  - Return an array of vault summaries.

- `GET /api/user/vaults/:vaultAddress/activity`
  - Look up `VaultActivity` rows for that vault from Prisma.
  - Return ordered by `createdAt desc`.

b) Merchants:
- `POST /api/merchant/apis`
  - Body: `{ adminAddress, payoutAddress, apiName, baseUrl, pricePerCall, chainId, tokenAddress }`.
  - Enforce `chainId === 137` for now, since we’re mainnet-only.
  - If this admin doesn’t have a `merchantId` yet:
    - Use `executorSigner` to call `MerchantRegistry.registerMerchant(payoutAddress)` on-chain (Polygon mainnet).
  - Upsert a `MerchantApi` row with that `merchantId`.
  - Return the API record.

- `GET /api/merchant/apis`
  - Header: `x-merchant-admin-address`.
  - Return `MerchantApi` records for that admin.

c) Agents:
- `POST /api/agents`
  - Body: `{ orgAddress, name, description, allowedVaults }`.
  - Generate `agentKey` (cryptographically secure random string).
  - Store in `Agent` table.
  - Return `{ agentKey }` (only once in the response).

- `GET /api/agents`
  - Header: `x-org-address`.
  - Return list of agents with masked/truncated `agentKey` (do not leak full secrets).

d) Analytics:
- `GET /api/analytics/user`
  - Header: `x-user-address`.
  - Aggregate `VaultActivity` by that user’s vaults to compute:
    - `totalSpend30d`
    - daily series for last 30 days
    - `spendByMerchant` (sum by merchantId).

- `GET /api/analytics/merchant`
  - Header: `x-merchant-admin-address`.
  - Aggregate `VaultActivity` + `MerchantApi` to compute:
    - `totalRevenue30d`
    - `callsPerDay`
    - top org addresses (masked).

4) x402-style “pay-and-call” endpoint (Polygon mainnet):

- `POST /api/pay-and-call`
  - Body: `{ agentKey, vaultAddress, merchantApiId, requestPath, payload }`.
  - Steps:
    1. Validate `agentKey` and that `vaultAddress` is included in its `allowedVaultAddresses`.
    2. Lookup `MerchantApi` by id (should be chainId 137).
    3. Compute `pricePerCall` as a BigNumber value in token units.
    4. Ensure PolicyVault on-chain rules allow this payment:
       - read `maxPerTx`, `dailyLimit`, `spentToday` from the vault contract on Polygon mainnet.
       - if not allowed, return 400 with an error.
    5. Call `PolicyVault.executePayment(merchantPayoutAddress, pricePerCall)` using `executorSigner` on Polygon mainnet.
    6. Wait for the tx, store a `VaultActivity` row with status 'success' and `txHash`.
    7. For now, perform a normal HTTP POST to `${baseUrl}${requestPath}` with `payload`, adding a header `x-shadowstream-paid: <txHash>`.
    8. Return the downstream API response plus our metadata.

Please:
- Implement all of this in `/backend` with clear separation of routes/controllers/services.
- Use TypeScript types.
- Update `/backend/package.json` dependencies (express/fastify, ethers, prisma, axios/fetch, etc.).
- Ensure `npm run dev` in `/backend` starts the server without type errors.


Prompt 7 – Connect Frontend /web to Backend & Polygon Mainnet Wallet
Now connect the existing `/web` frontend to the real backend and a wallet on **Polygon mainnet**.

Goals:
- Frontend uses:
  - `VITE_BACKEND_URL` to call the backend.
  - `VITE_CHAIN_ID = "137"` for Polygon mainnet.
  - `VITE_POLICY_VAULT_FACTORY_ADDRESS` and `VITE_MERCHANT_REGISTRY_ADDRESS` to display correct info.
- Replace any static/demo data with real API calls.

Tasks:

1) API client:
- Create `/web/src/lib/api.ts` with functions that call the backend using `fetch` or axios:
  - `getUserVaults(userAddress)`
  - `createPolicyVault(input)`
  - `getVaultActivity(vaultAddress)`
  - `getUserAnalytics(userAddress)`
  - `getMerchantApis(adminAddress)`
  - `createMerchantApi(input)`
  - `createAgent(input)`
  - `getAgents(orgAddress)`
  - `payAndCall(input)`

Each should:
- Use `import { config } from "./config"` to get `backendUrl`.
- Attach headers where appropriate:
  - `x-user-address` for user-specific calls.
  - `x-merchant-admin-address` for merchant endpoints.
  - `x-org-address` for agent/analytics endpoints.

2) Data hooks:
- If React Query or similar is present, create hooks:
  - `useUserVaults(userAddress)`
  - `useVaultActivity(vaultAddress)`
  - `useUserAnalytics(userAddress)`
  - `useMerchantApis(adminAddress)`
  - `useAgents(orgAddress)`
- Wire these into:
  - User/Org Overview page.
  - Vaults list page.
  - Vault detail page.
  - Merchant APIs page.
  - Agents page.
  - Transactions/analytics components.

3) Replace demo/static data:
- Find components that render:
  - fake vault cards
  - dummy analytics
  - hard-coded transactions
- Replace them with calls to the hooks above, with clear loading and error states.

4) Wallet connection (Polygon mainnet):
- Implement a minimal wallet connect using MetaMask or any injected provider:
  - Create a `useWallet` hook or `WalletContext` that manages:
    - `address`
    - `chainId`
    - `isConnected`
    - `connect()` which calls `window.ethereum.request({ method: "eth_requestAccounts" })`.
    - `ensureMainnet()` which:
      - checks current chainId
      - if not `0x89` (137), requests a network switch to Polygon mainnet using `wallet_switchEthereumChain`.
  - Integrate this into the top nav/app layout so that:
    - When user connects:
      - We store `address` globally.
      - User views use this address for `x-user-address` requests.
      - Merchant views treat the same address as `x-merchant-admin-address`.

5) Vault creation flow:
- In the “Create Policy Vault” flow:
  - On submit:
    - Map selected token (USDC/USDT) to real Polygon mainnet token addresses using a token map in `/web/src/lib/tokens.ts`.
    - Call `createPolicyVault` with:
      - `userAddress` from wallet.
      - `tokenAddress` (USDC or USDT on mainnet).
      - `maxPerTx` and `dailyLimit` as decimal strings.
    - On success:
      - Show a success toast.
      - Navigate to `/app/user/vaults` and refresh.

6) Vault detail:
- Use `vaultAddress` from route params.
- Call `getVaultActivity(vaultAddress)` and show transaction list.
- For spend vs limit, use data returned from `getUserVaults` or a dedicated backend endpoint:
  - `maxPerTx`, `dailyLimit`, `spentToday`.

7) Merchant pages:
- On merchant dashboard:
  - Use wallet address as `adminAddress`.
  - List APIs using `getMerchantApis(adminAddress)`.
  - Create APIs with `createMerchantApi`.

8) Agent credentials:
- On “Create Agent Credential”:
  - Call `createAgent` with:
    - `orgAddress` = wallet address
    - selected `allowedVaults`.
  - Display returned `agentKey` in a modal with a copy button.
  - Ensure you never log `agentKey` in console.

9) Test payment UX (on Polygon mainnet, be careful with real value):
- Add a “Test Payment” component in a relevant page:
  - Allow selection of:
    - A vault
    - A merchant API
    - A simple path like `/test`
  - Call `payAndCall` on the backend with:
    - the selected `vaultAddress`
    - `merchantApiId`
    - `requestPath`
    - a simple JSON payload
  - Display:
    - On-chain tx hash
    - Status
    - Downstream API response JSON.

Please:
- Implement these connections step-by-step.
- Ensure TypeScript types in `/web/src/types` are accurate.
- Remove remaining mocks and wire everything to real backend endpoints operating on Polygon mainnet (chainId 137).